## 1.new关键词创建与字面量创建

```
var obj1 = new Object()
obj1.name = 'tom'
obj1.age = 22
obj1.job = 'engineer'


var obj2 = {
  name: 'tom',
  age: 22,
  job: 'engineer'
}


```
使用这两种方式都可以进行对象的创建，可以看到字面量创建对象的方式要比使用new操作符操作Object构造函数更为简洁，但是这两种方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。

## 2.工厂模式

```
function createPerson(name, age, job) {
  var o = new Object;
  o.name = name
  o.age = age
  o.job = job
  o.sayName = function() {
    console.log(this.name)
  }
  return o
}
var person = createPerson('tom', 22, 'engineer')
console.log(person)                 //{name: 'tom', age: 22, job: 'engineer', sayName: function() {console.log(this.name)}}
var person2 = createPerson('jerry')
console.log(person2)                //{name: 'jerry', age: undefined, job: undefined, sayName: function() {console.log(this.name)}}
```

优点：相比使用new操作符创建和字面量创建具有良好的封装性，解决了创建多个相似对象的问题  
缺点：所有实例都执行同一个原型Object

## 3.构造函数模式
```
function Person(name, age, job) {
  this.name = name
  this.age = age
  this.job = job
  this.sayName = function() {
    console.log(this.name)
  }
}

var person = new Person('tom', 22, 'engineer')
console.log(person)           //{name: 'tom', age: 22, job: 'engineer', sayName: function() {console.log(this.name)}}

var person2 = new Person('jerry', 18)
console.log(person2)          //{name: 'jerry', age: 18, sayName: function() {console.log(this.name)}}

console.log(person intanceof Person)                //true
console.log(person intanceof Object)                //true  (person的原型链中存在Object.prototype属性)
console.log(person2 intanceof Person)               //true
console.log(person2 intanceof Object)               //true

console.log(person.sayName == person2.sayName)      //false
```

优点：可以检测到对象的类型  
缺点：创建实例时，每个方法都要在每个实例上重新创建一遍  
解决方案：将方法在全局作用域中声明，在构造函数中引用。但是这种方案体现不出封装性，并且方法较多时不便维护

构造函数与其他函数的区别就是在于他们的调用方式不同，任何函数只要通过new操作符来调用，它就可以作为构造函数，只是我们在写法上将函数首字母大写用来区分构造函数和普通函数  

还是应用上面的例子: 

```
var person = new Person('tom', 22)          //当作构造函数来调用
person.sayName()                            //tom

Person('jerry')                             //当作普通函数调用
window.sayName()                            //'jerry'

var o = {}
Person.call(o, 'greg')                      //在另一个对象的作用域中调用
o.sayName()                                 //'gerg'
```
## 原型模式

```
function Person() {}
Person.prototype.name = 'tom'
Person.prototype.age = 22
Person.prototype.hobby = ['games', 'singing']
Person.prototype.sayName = function() {
  console.log(this.name)
}

var person = new Person()
var person2 = new Person()
console.log(person.sayName == person.sayName)  //true (person和person2的原型链上都存在Person.prototype，所以访问的属性是共同的)

person.name = 'jerry'
coonsole.log(person.name)                      //'jerry'
console.log(person2.name)                      //'tom'
//当读取person的name值时，先从person本身属性中去查找，发现有name这个属性，返回name，所以name值为jerry
//当读取person2的name值时，先从person本身属性中去查找，没发现有name这个属性，因此会继续通过原型去查找，在原型中找到name，所以返回tom

person.job = 'engineer'
console.log(person.job)                        //'engineer'
console.log(person2.job)                       //undefiend
//在本身属性中没有找到，原型中也没有找到，所以返回undefined

person.hobby.push('basketball')
console.log(person.hobby)                      //['games', 'singing', 'basketball']
console.log(person2.hobby)                     //['games', 'singing', 'basketball']
//要清楚这里是对Person.prototype.hobby进行操作，而不是实例本身的属性

```
优点：方法不会重新创建  
缺点：所有实例属性和方法共享
